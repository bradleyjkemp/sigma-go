package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strconv"
	"text/template"

	"github.com/bradleyjkemp/sigma-go"
	"gopkg.in/yaml.v3"
)

var (
	fRecursive = flag.Bool("recursive", true, "whether to compile directories recursively")
)

func main() {
	flag.Parse()

	paths := flag.Args()
	if len(paths) == 0 {
		paths = []string{"."}
	}

	for _, path := range paths {
		if err := run(path, *fRecursive); err != nil {
			fmt.Println(err)
			os.Exit(1)
		}
	}
}

func run(root string, recursive bool) error {
	directories := map[string]struct{}{}
	rulesByDirectory := map[string][]string{}
	configByDirectory := map[string][]string{}

	// Collect all the rules under this root
	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			if path != root && !recursive {
				return filepath.SkipDir
			}
			return nil
		}

		if filepath.Ext(path) != ".yaml" && filepath.Ext(path) != ".yml" {
			return nil
		}

		contents, err := ioutil.ReadFile(path)
		if err != nil {
			return fmt.Errorf("error reading %s: %w", path, err)
		}

		var ruleOrConfig ruleOrConfig
		yaml.Unmarshal(contents, &ruleOrConfig)

		if ruleOrConfig.IsRule() {
			// Just check the rule is valid
			_, err = sigma.ParseRule(contents)
			if err != nil {
				return fmt.Errorf("error parsing %s: %w", path, err)
			}

			dir := filepath.Dir(path)
			directories[dir] = struct{}{}
			rulesByDirectory[dir] = append(rulesByDirectory[dir], strconv.Quote(string(contents)))
		} else {
			// Just check the config is valid
			_, err = sigma.ParseConfig(contents)
			if err != nil {
				return fmt.Errorf("error parsing %s: %w", path, err)
			}

			dir := filepath.Dir(path)
			directories[dir] = struct{}{}
			configByDirectory[dir] = append(configByDirectory[dir], strconv.Quote(string(contents)))
		}

		return nil
	})
	if err != nil {
		return err
	}

	// For each directory containing Sigma rules, write a sigma.go file containing all the rules
	for dir := range directories {
		registryFile, err := os.OpenFile(filepath.Join(dir, "sigma.go"), os.O_CREATE|os.O_RDWR|os.O_TRUNC, 0755)
		if err != nil {
			return err
		}
		_, packageName := filepath.Split(dir)
		params := map[string]interface{}{
			"PackageName": packageName,
			"Rules":       rulesByDirectory[dir],
			"Configs":     configByDirectory[dir],
		}
		err = registryTmpl.Execute(registryFile, params)
		if err != nil {
			return err
		}
	}

	return nil
}

var registryTmpl = template.Must(template.New("registry").Parse(`// Code generated by github.com/bradleyjkemp/sigma-go/sigmac DO NOT EDIT.
package {{.PackageName}}

import (
	sigma "github.com/bradleyjkemp/sigma-go"

	"sort"
)

var Rules = map[string]sigma.Rule{}

var Configs []sigma.Config

func registerRule(contents string) {
	// TODO: it'd be better if this were already parsed rather than being parsed at runtime
	rule, err := sigma.ParseRule([]byte(contents))
	if err != nil {
		panic(err)
	}

	id := rule.ID
	if id == "" {
		id = "MISSING_ID_"+rule.Title
	}

	if _, ok := Rules[id]; ok {
		panic("rule with id "+id+" already registered")
	}
	Rules[id] = rule
}

func registerConfig(contents string) {
	// TODO: it'd be better if this were already parsed rather than being parsed at runtime
	config, err := sigma.ParseConfig([]byte(contents))
	if err != nil {
		panic(err)
	}

	Configs = append(Configs, config)
	sort.Slice(Configs, func(i, j int) bool {
		return Configs[i].Order < Configs[j].Order
	})
}
{{range .Rules}}
func init() {
	registerRule({{.}})
}
{{end}}{{range .Configs}}
func init() {
	registerConfig({{.}})
}
{{end}}
`))
